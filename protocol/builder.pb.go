// Code generated by protoc-gen-go.
// source: protocol/builder.proto
// DO NOT EDIT!

/*
Package protocol is a generated protocol buffer package.

It is generated from these files:
	protocol/builder.proto

It has these top-level messages:
	BooleanMessage
	StringMessage
	StringListMessage
	SubscribeRequest
	SubscribeResponse
	UnsubscribeRequest
	UnsubscribeResponse
	CollectJobRequest
	CollectJobResponse
	JobRequest
	SlaveStartRequest
	JobUpdateRequest
	StepUpdateRequest
	PickJobRequest
	UploadRequest
	UploadChunk
	UploadEnd
	UploadMessage
	UploadResponse
	DownloadRequest
	DownloadChunk
	DownloadEnd
	DownloadResponse
	VcsInfo
	PackageInfo
	ImageInfo
*/
package protocol

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Job status.
type EnumJobStatus int32

const (
	EnumJobStatus_JOB_STATUS_JUST_CREATED EnumJobStatus = 0
	EnumJobStatus_JOB_STATUS_WAITING      EnumJobStatus = 1
	EnumJobStatus_JOB_STATUS_PROCESSING   EnumJobStatus = 2
	EnumJobStatus_JOB_STATUS_SUCCESSFUL   EnumJobStatus = 3
	EnumJobStatus_JOB_STATUS_FAILED       EnumJobStatus = 4
	EnumJobStatus_JOB_STATUS_CRASHED      EnumJobStatus = 5
)

var EnumJobStatus_name = map[int32]string{
	0: "JOB_STATUS_JUST_CREATED",
	1: "JOB_STATUS_WAITING",
	2: "JOB_STATUS_PROCESSING",
	3: "JOB_STATUS_SUCCESSFUL",
	4: "JOB_STATUS_FAILED",
	5: "JOB_STATUS_CRASHED",
}
var EnumJobStatus_value = map[string]int32{
	"JOB_STATUS_JUST_CREATED": 0,
	"JOB_STATUS_WAITING":      1,
	"JOB_STATUS_PROCESSING":   2,
	"JOB_STATUS_SUCCESSFUL":   3,
	"JOB_STATUS_FAILED":       4,
	"JOB_STATUS_CRASHED":      5,
}

func (x EnumJobStatus) String() string {
	return proto.EnumName(EnumJobStatus_name, int32(x))
}

// Build target.
type EnumTargetType int32

const (
	EnumTargetType_PACKAGE EnumTargetType = 0
	EnumTargetType_IMAGE   EnumTargetType = 1
)

var EnumTargetType_name = map[int32]string{
	0: "PACKAGE",
	1: "IMAGE",
}
var EnumTargetType_value = map[string]int32{
	"PACKAGE": 0,
	"IMAGE":   1,
}

func (x EnumTargetType) String() string {
	return proto.EnumName(EnumTargetType_name, int32(x))
}

// Generic boolean message.
type BooleanMessage struct {
	// Result.
	Result bool `protobuf:"varint,1,opt,name=result" json:"result,omitempty"`
}

func (m *BooleanMessage) Reset()         { *m = BooleanMessage{} }
func (m *BooleanMessage) String() string { return proto.CompactTextString(m) }
func (*BooleanMessage) ProtoMessage()    {}

// Generic string message.
type StringMessage struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *StringMessage) Reset()         { *m = StringMessage{} }
func (m *StringMessage) String() string { return proto.CompactTextString(m) }
func (*StringMessage) ProtoMessage()    {}

// Generic string list message.
type StringListMessage struct {
	List []string `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *StringListMessage) Reset()         { *m = StringListMessage{} }
func (m *StringListMessage) String() string { return proto.CompactTextString(m) }
func (*StringListMessage) ProtoMessage()    {}

// Subscription request.
type SubscribeRequest struct {
	// Name.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Topics.
	Types []string `protobuf:"bytes,2,rep,name=types" json:"types,omitempty"`
	// Architectures.
	Architectures []string `protobuf:"bytes,3,rep,name=architectures" json:"architectures,omitempty"`
}

func (m *SubscribeRequest) Reset()         { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()    {}

// Subscription response.
type SubscribeResponse struct {
	// Slave identifier.
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Images repository path.
	ImagesDir string `protobuf:"bytes,2,opt,name=images_dir" json:"images_dir,omitempty"`
	// Generic repository URL with replaceble strings such as $releasever
	// and $basearch (respectively with the Fedora version we are based on
	// and the job architecture).
	// A repository URL is something like:
	//   http://localhost:8020/repo/main/fedora/releases/$releasever/$basearch/os
	RepoUrl string `protobuf:"bytes,3,opt,name=repo_url" json:"repo_url,omitempty"`
}

func (m *SubscribeResponse) Reset()         { *m = SubscribeResponse{} }
func (m *SubscribeResponse) String() string { return proto.CompactTextString(m) }
func (*SubscribeResponse) ProtoMessage()    {}

// Unsubscription request.
type UnsubscribeRequest struct {
	// Slave identifier.
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *UnsubscribeRequest) Reset()         { *m = UnsubscribeRequest{} }
func (m *UnsubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*UnsubscribeRequest) ProtoMessage()    {}

// Unsubscription response.
type UnsubscribeResponse struct {
	// Result.
	Result bool `protobuf:"varint,1,opt,name=result" json:"result,omitempty"`
}

func (m *UnsubscribeResponse) Reset()         { *m = UnsubscribeResponse{} }
func (m *UnsubscribeResponse) String() string { return proto.CompactTextString(m) }
func (*UnsubscribeResponse) ProtoMessage()    {}

// CollectJob request.
type CollectJobRequest struct {
	// Target name
	Target string `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	// Target architecture.
	Architecture string `protobuf:"bytes,2,opt,name=architecture" json:"architecture,omitempty"`
	// Target type.
	Type EnumTargetType `protobuf:"varint,3,opt,name=type,enum=protocol.EnumTargetType" json:"type,omitempty"`
}

func (m *CollectJobRequest) Reset()         { *m = CollectJobRequest{} }
func (m *CollectJobRequest) String() string { return proto.CompactTextString(m) }
func (*CollectJobRequest) ProtoMessage()    {}

// CollectJob response.
type CollectJobResponse struct {
	// Result.
	Result bool `protobuf:"varint,1,opt,name=result" json:"result,omitempty"`
	// Identifier.
	Id uint64 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
}

func (m *CollectJobResponse) Reset()         { *m = CollectJobResponse{} }
func (m *CollectJobResponse) String() string { return proto.CompactTextString(m) }
func (*CollectJobResponse) ProtoMessage()    {}

// Contains information on the job that has to be processed by
// the slave receiving this.
type JobRequest struct {
	// Identifier.
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Payload.
	//
	// Types that are valid to be assigned to Payload:
	//	*JobRequest_Package
	//	*JobRequest_Image
	Payload isJobRequest_Payload `protobuf_oneof:"payload"`
}

func (m *JobRequest) Reset()         { *m = JobRequest{} }
func (m *JobRequest) String() string { return proto.CompactTextString(m) }
func (*JobRequest) ProtoMessage()    {}

type isJobRequest_Payload interface {
	isJobRequest_Payload()
}

type JobRequest_Package struct {
	Package *PackageInfo `protobuf:"bytes,2,opt,name=package,oneof"`
}
type JobRequest_Image struct {
	Image *ImageInfo `protobuf:"bytes,3,opt,name=image,oneof"`
}

func (*JobRequest_Package) isJobRequest_Payload() {}
func (*JobRequest_Image) isJobRequest_Payload()   {}

func (m *JobRequest) GetPayload() isJobRequest_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *JobRequest) GetPackage() *PackageInfo {
	if x, ok := m.GetPayload().(*JobRequest_Package); ok {
		return x.Package
	}
	return nil
}

func (m *JobRequest) GetImage() *ImageInfo {
	if x, ok := m.GetPayload().(*JobRequest_Image); ok {
		return x.Image
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*JobRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _JobRequest_OneofMarshaler, _JobRequest_OneofUnmarshaler, []interface{}{
		(*JobRequest_Package)(nil),
		(*JobRequest_Image)(nil),
	}
}

func _JobRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*JobRequest)
	// payload
	switch x := m.Payload.(type) {
	case *JobRequest_Package:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Package); err != nil {
			return err
		}
	case *JobRequest_Image:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Image); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("JobRequest.Payload has unexpected type %T", x)
	}
	return nil
}

func _JobRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*JobRequest)
	switch tag {
	case 2: // payload.package
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PackageInfo)
		err := b.DecodeMessage(msg)
		m.Payload = &JobRequest_Package{msg}
		return true, err
	case 3: // payload.image
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImageInfo)
		err := b.DecodeMessage(msg)
		m.Payload = &JobRequest_Image{msg}
		return true, err
	default:
		return false, nil
	}
}

// Ask the master to start the slave loop.
type SlaveStartRequest struct {
	// Slave identifier.
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *SlaveStartRequest) Reset()         { *m = SlaveStartRequest{} }
func (m *SlaveStartRequest) String() string { return proto.CompactTextString(m) }
func (*SlaveStartRequest) ProtoMessage()    {}

// Contains updated information on a job being processed.
type JobUpdateRequest struct {
	// Identifier.
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Current status of the job.
	Status EnumJobStatus `protobuf:"varint,2,opt,name=status,enum=protocol.EnumJobStatus" json:"status,omitempty"`
}

func (m *JobUpdateRequest) Reset()         { *m = JobUpdateRequest{} }
func (m *JobUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*JobUpdateRequest) ProtoMessage()    {}

// Contains updated information on a build step being executed.
type StepUpdateRequest struct {
	// Job identifier.
	JobId uint64 `protobuf:"varint,1,opt,name=job_id" json:"job_id,omitempty"`
	// Name.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Whether it's still running.
	Running bool `protobuf:"varint,3,opt,name=running" json:"running,omitempty"`
	// When it has started (nanoseconds since Epoch).
	Started int64 `protobuf:"varint,4,opt,name=started" json:"started,omitempty"`
	// When it has finished (nanoseconds since Epoch).
	Finished int64 `protobuf:"varint,5,opt,name=finished" json:"finished,omitempty"`
	// Optional summary of this step.
	Summary map[string]string `protobuf:"bytes,6,rep,name=summary" json:"summary,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Other optional logs.
	Logs map[string][]byte `protobuf:"bytes,7,rep,name=logs" json:"logs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *StepUpdateRequest) Reset()         { *m = StepUpdateRequest{} }
func (m *StepUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*StepUpdateRequest) ProtoMessage()    {}

func (m *StepUpdateRequest) GetSummary() map[string]string {
	if m != nil {
		return m.Summary
	}
	return nil
}

func (m *StepUpdateRequest) GetLogs() map[string][]byte {
	if m != nil {
		return m.Logs
	}
	return nil
}

// Communication from slave to master.
type PickJobRequest struct {
	// Types that are valid to be assigned to Payload:
	//	*PickJobRequest_SlaveStart
	//	*PickJobRequest_JobUpdate
	//	*PickJobRequest_StepUpdate
	Payload isPickJobRequest_Payload `protobuf_oneof:"payload"`
}

func (m *PickJobRequest) Reset()         { *m = PickJobRequest{} }
func (m *PickJobRequest) String() string { return proto.CompactTextString(m) }
func (*PickJobRequest) ProtoMessage()    {}

type isPickJobRequest_Payload interface {
	isPickJobRequest_Payload()
}

type PickJobRequest_SlaveStart struct {
	SlaveStart *SlaveStartRequest `protobuf:"bytes,1,opt,name=slave_start,oneof"`
}
type PickJobRequest_JobUpdate struct {
	JobUpdate *JobUpdateRequest `protobuf:"bytes,2,opt,name=job_update,oneof"`
}
type PickJobRequest_StepUpdate struct {
	StepUpdate *StepUpdateRequest `protobuf:"bytes,3,opt,name=step_update,oneof"`
}

func (*PickJobRequest_SlaveStart) isPickJobRequest_Payload() {}
func (*PickJobRequest_JobUpdate) isPickJobRequest_Payload()  {}
func (*PickJobRequest_StepUpdate) isPickJobRequest_Payload() {}

func (m *PickJobRequest) GetPayload() isPickJobRequest_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *PickJobRequest) GetSlaveStart() *SlaveStartRequest {
	if x, ok := m.GetPayload().(*PickJobRequest_SlaveStart); ok {
		return x.SlaveStart
	}
	return nil
}

func (m *PickJobRequest) GetJobUpdate() *JobUpdateRequest {
	if x, ok := m.GetPayload().(*PickJobRequest_JobUpdate); ok {
		return x.JobUpdate
	}
	return nil
}

func (m *PickJobRequest) GetStepUpdate() *StepUpdateRequest {
	if x, ok := m.GetPayload().(*PickJobRequest_StepUpdate); ok {
		return x.StepUpdate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PickJobRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _PickJobRequest_OneofMarshaler, _PickJobRequest_OneofUnmarshaler, []interface{}{
		(*PickJobRequest_SlaveStart)(nil),
		(*PickJobRequest_JobUpdate)(nil),
		(*PickJobRequest_StepUpdate)(nil),
	}
}

func _PickJobRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PickJobRequest)
	// payload
	switch x := m.Payload.(type) {
	case *PickJobRequest_SlaveStart:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SlaveStart); err != nil {
			return err
		}
	case *PickJobRequest_JobUpdate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.JobUpdate); err != nil {
			return err
		}
	case *PickJobRequest_StepUpdate:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StepUpdate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PickJobRequest.Payload has unexpected type %T", x)
	}
	return nil
}

func _PickJobRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PickJobRequest)
	switch tag {
	case 1: // payload.slave_start
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SlaveStartRequest)
		err := b.DecodeMessage(msg)
		m.Payload = &PickJobRequest_SlaveStart{msg}
		return true, err
	case 2: // payload.job_update
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JobUpdateRequest)
		err := b.DecodeMessage(msg)
		m.Payload = &PickJobRequest_JobUpdate{msg}
		return true, err
	case 3: // payload.step_update
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StepUpdateRequest)
		err := b.DecodeMessage(msg)
		m.Payload = &PickJobRequest_StepUpdate{msg}
		return true, err
	default:
		return false, nil
	}
}

// An upload request.
type UploadRequest struct {
	// Desired file name.
	FileName string `protobuf:"bytes,1,opt,name=file_name" json:"file_name,omitempty"`
	// Fedora release version.
	ReleaseVer string `protobuf:"bytes,2,opt,name=release_ver" json:"release_ver,omitempty"`
	// Package architecture.
	BaseArch string `protobuf:"bytes,3,opt,name=base_arch" json:"base_arch,omitempty"`
}

func (m *UploadRequest) Reset()         { *m = UploadRequest{} }
func (m *UploadRequest) String() string { return proto.CompactTextString(m) }
func (*UploadRequest) ProtoMessage()    {}

// Chunk of a file being uploaded.
type UploadChunk struct {
	// A chunk of data.
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *UploadChunk) Reset()         { *m = UploadChunk{} }
func (m *UploadChunk) String() string { return proto.CompactTextString(m) }
func (*UploadChunk) ProtoMessage()    {}

// Signal the end of upload.
type UploadEnd struct {
	// SHA256 hash of the whole file.
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// Desired permission.
	Permission uint32 `protobuf:"varint,2,opt,name=permission" json:"permission,omitempty"`
}

func (m *UploadEnd) Reset()         { *m = UploadEnd{} }
func (m *UploadEnd) String() string { return proto.CompactTextString(m) }
func (*UploadEnd) ProtoMessage()    {}

// Upload message.
type UploadMessage struct {
	// Types that are valid to be assigned to Payload:
	//	*UploadMessage_Request
	//	*UploadMessage_Chunk
	//	*UploadMessage_End
	Payload isUploadMessage_Payload `protobuf_oneof:"payload"`
}

func (m *UploadMessage) Reset()         { *m = UploadMessage{} }
func (m *UploadMessage) String() string { return proto.CompactTextString(m) }
func (*UploadMessage) ProtoMessage()    {}

type isUploadMessage_Payload interface {
	isUploadMessage_Payload()
}

type UploadMessage_Request struct {
	Request *UploadRequest `protobuf:"bytes,1,opt,name=request,oneof"`
}
type UploadMessage_Chunk struct {
	Chunk *UploadChunk `protobuf:"bytes,2,opt,name=chunk,oneof"`
}
type UploadMessage_End struct {
	End *UploadEnd `protobuf:"bytes,3,opt,name=end,oneof"`
}

func (*UploadMessage_Request) isUploadMessage_Payload() {}
func (*UploadMessage_Chunk) isUploadMessage_Payload()   {}
func (*UploadMessage_End) isUploadMessage_Payload()     {}

func (m *UploadMessage) GetPayload() isUploadMessage_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *UploadMessage) GetRequest() *UploadRequest {
	if x, ok := m.GetPayload().(*UploadMessage_Request); ok {
		return x.Request
	}
	return nil
}

func (m *UploadMessage) GetChunk() *UploadChunk {
	if x, ok := m.GetPayload().(*UploadMessage_Chunk); ok {
		return x.Chunk
	}
	return nil
}

func (m *UploadMessage) GetEnd() *UploadEnd {
	if x, ok := m.GetPayload().(*UploadMessage_End); ok {
		return x.End
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*UploadMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _UploadMessage_OneofMarshaler, _UploadMessage_OneofUnmarshaler, []interface{}{
		(*UploadMessage_Request)(nil),
		(*UploadMessage_Chunk)(nil),
		(*UploadMessage_End)(nil),
	}
}

func _UploadMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*UploadMessage)
	// payload
	switch x := m.Payload.(type) {
	case *UploadMessage_Request:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Request); err != nil {
			return err
		}
	case *UploadMessage_Chunk:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Chunk); err != nil {
			return err
		}
	case *UploadMessage_End:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.End); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("UploadMessage.Payload has unexpected type %T", x)
	}
	return nil
}

func _UploadMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*UploadMessage)
	switch tag {
	case 1: // payload.request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UploadRequest)
		err := b.DecodeMessage(msg)
		m.Payload = &UploadMessage_Request{msg}
		return true, err
	case 2: // payload.chunk
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UploadChunk)
		err := b.DecodeMessage(msg)
		m.Payload = &UploadMessage_Chunk{msg}
		return true, err
	case 3: // payload.end
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UploadEnd)
		err := b.DecodeMessage(msg)
		m.Payload = &UploadMessage_End{msg}
		return true, err
	default:
		return false, nil
	}
}

// Upload response.
type UploadResponse struct {
	// How many bytes were written so far.
	TotalSize int64 `protobuf:"varint,1,opt,name=total_size" json:"total_size,omitempty"`
	// Error message (empty if no error).
	Error string `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *UploadResponse) Reset()         { *m = UploadResponse{} }
func (m *UploadResponse) String() string { return proto.CompactTextString(m) }
func (*UploadResponse) ProtoMessage()    {}

// A download request.
type DownloadRequest struct {
	// Desired file name.
	FileName string `protobuf:"bytes,1,opt,name=file_name" json:"file_name,omitempty"`
}

func (m *DownloadRequest) Reset()         { *m = DownloadRequest{} }
func (m *DownloadRequest) String() string { return proto.CompactTextString(m) }
func (*DownloadRequest) ProtoMessage()    {}

// Chunk of a file being downloaded.
type DownloadChunk struct {
	// A chunk of data.
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	// SHA256 hash of this chunk.
	Hash []byte `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *DownloadChunk) Reset()         { *m = DownloadChunk{} }
func (m *DownloadChunk) String() string { return proto.CompactTextString(m) }
func (*DownloadChunk) ProtoMessage()    {}

// Signal the end of download.
type DownloadEnd struct {
	// SHA256 hash of the whole file.
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// Total file size
	Size int64 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
}

func (m *DownloadEnd) Reset()         { *m = DownloadEnd{} }
func (m *DownloadEnd) String() string { return proto.CompactTextString(m) }
func (*DownloadEnd) ProtoMessage()    {}

// Download response.
type DownloadResponse struct {
	// Types that are valid to be assigned to Payload:
	//	*DownloadResponse_Chunk
	//	*DownloadResponse_End
	Payload isDownloadResponse_Payload `protobuf_oneof:"payload"`
}

func (m *DownloadResponse) Reset()         { *m = DownloadResponse{} }
func (m *DownloadResponse) String() string { return proto.CompactTextString(m) }
func (*DownloadResponse) ProtoMessage()    {}

type isDownloadResponse_Payload interface {
	isDownloadResponse_Payload()
}

type DownloadResponse_Chunk struct {
	Chunk *DownloadChunk `protobuf:"bytes,1,opt,name=chunk,oneof"`
}
type DownloadResponse_End struct {
	End *DownloadEnd `protobuf:"bytes,2,opt,name=end,oneof"`
}

func (*DownloadResponse_Chunk) isDownloadResponse_Payload() {}
func (*DownloadResponse_End) isDownloadResponse_Payload()   {}

func (m *DownloadResponse) GetPayload() isDownloadResponse_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *DownloadResponse) GetChunk() *DownloadChunk {
	if x, ok := m.GetPayload().(*DownloadResponse_Chunk); ok {
		return x.Chunk
	}
	return nil
}

func (m *DownloadResponse) GetEnd() *DownloadEnd {
	if x, ok := m.GetPayload().(*DownloadResponse_End); ok {
		return x.End
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DownloadResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _DownloadResponse_OneofMarshaler, _DownloadResponse_OneofUnmarshaler, []interface{}{
		(*DownloadResponse_Chunk)(nil),
		(*DownloadResponse_End)(nil),
	}
}

func _DownloadResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DownloadResponse)
	// payload
	switch x := m.Payload.(type) {
	case *DownloadResponse_Chunk:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Chunk); err != nil {
			return err
		}
	case *DownloadResponse_End:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.End); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DownloadResponse.Payload has unexpected type %T", x)
	}
	return nil
}

func _DownloadResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DownloadResponse)
	switch tag {
	case 1: // payload.chunk
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DownloadChunk)
		err := b.DecodeMessage(msg)
		m.Payload = &DownloadResponse_Chunk{msg}
		return true, err
	case 2: // payload.end
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DownloadEnd)
		err := b.DecodeMessage(msg)
		m.Payload = &DownloadResponse_End{msg}
		return true, err
	default:
		return false, nil
	}
}

// VCS information.
type VcsInfo struct {
	Url    string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	Branch string `protobuf:"bytes,2,opt,name=branch" json:"branch,omitempty"`
}

func (m *VcsInfo) Reset()         { *m = VcsInfo{} }
func (m *VcsInfo) String() string { return proto.CompactTextString(m) }
func (*VcsInfo) ProtoMessage()    {}

// Package information.
type PackageInfo struct {
	// Name.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Architectures supported.
	Architectures []string `protobuf:"bytes,2,rep,name=architectures" json:"architectures,omitempty"`
	// Is it a CI package?
	Ci bool `protobuf:"varint,3,opt,name=ci" json:"ci,omitempty"`
	// VCS for packaging.
	Vcs *VcsInfo `protobuf:"bytes,4,opt,name=vcs" json:"vcs,omitempty"`
	// VCS for upstream (only for CI).
	UpstreamVcs *VcsInfo `protobuf:"bytes,5,opt,name=upstream_vcs" json:"upstream_vcs,omitempty"`
}

func (m *PackageInfo) Reset()         { *m = PackageInfo{} }
func (m *PackageInfo) String() string { return proto.CompactTextString(m) }
func (*PackageInfo) ProtoMessage()    {}

func (m *PackageInfo) GetVcs() *VcsInfo {
	if m != nil {
		return m.Vcs
	}
	return nil
}

func (m *PackageInfo) GetUpstreamVcs() *VcsInfo {
	if m != nil {
		return m.UpstreamVcs
	}
	return nil
}

// Image information.
type ImageInfo struct {
	// Name.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Description.
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	// Architectures supported.
	Architectures []string `protobuf:"bytes,3,rep,name=architectures" json:"architectures,omitempty"`
	// VCS with build scripts.
	Vcs *VcsInfo `protobuf:"bytes,4,opt,name=vcs" json:"vcs,omitempty"`
}

func (m *ImageInfo) Reset()         { *m = ImageInfo{} }
func (m *ImageInfo) String() string { return proto.CompactTextString(m) }
func (*ImageInfo) ProtoMessage()    {}

func (m *ImageInfo) GetVcs() *VcsInfo {
	if m != nil {
		return m.Vcs
	}
	return nil
}

func init() {
	proto.RegisterEnum("protocol.EnumJobStatus", EnumJobStatus_name, EnumJobStatus_value)
	proto.RegisterEnum("protocol.EnumTargetType", EnumTargetType_name, EnumTargetType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Builder service

type BuilderClient interface {
	// Subscribe to the master.
	//
	// A slave calls this method to register itself on the master, which will
	// assign an identifier returned with the reply, along with some information
	// such as the repositories paths.
	//
	// Keep in mind that identifiers are valid until master is restarted.
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error)
	// Unregister a slave.
	//
	// Slave class this procedure to unregister itself.
	// Master replies indicating whether the operation succeded or not.
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error)
	// Send a job to the collector.
	//
	// Master will enqueue a new job and the dispatcher will find a suitable
	// slave and dispatch to it.
	CollectJob(ctx context.Context, in *CollectJobRequest, opts ...grpc.CallOption) (*CollectJobResponse, error)
	// Pick up a job from the master.
	//
	// Once a slave has subscribed a full duplex communication is established
	// until the slave unsubscribe or the master quits, in that case the slave
	// detects that the connection is no longer valid and will resubscribe if
	// and when master comes up again.
	//
	// Master sends jobs to be processed through the stream as they are collected
	// and dispatched.  Jobs are dispatched to slaves whose capacity has not been
	// reached yet and whose topic matches.
	PickJob(ctx context.Context, opts ...grpc.CallOption) (Builder_PickJobClient, error)
	// Upload a file to the master.
	//
	// Upload an artifact to the staging repository, a chunk at a time
	// via streaming.
	Upload(ctx context.Context, opts ...grpc.CallOption) (Builder_UploadClient, error)
	// Download a file from the master.
	//
	// Send a file from master to slave, a chunk at a time via streaming.
	Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (Builder_DownloadClient, error)
	// Add or update a package.
	//
	// Store package information so that it can be referenced later when
	// scheduling a job.
	AddPackage(ctx context.Context, in *PackageInfo, opts ...grpc.CallOption) (*BooleanMessage, error)
	// Remove a package.
	//
	// Remove package information.
	RemovePackage(ctx context.Context, in *StringMessage, opts ...grpc.CallOption) (*BooleanMessage, error)
	// List packages.
	//
	// Return the list of packages and their information, matching the
	// regular expression passed as argument.
	// With an empty string the full list of packages will be retrieved.
	ListPackages(ctx context.Context, in *StringMessage, opts ...grpc.CallOption) (Builder_ListPackagesClient, error)
	// Add or update an image.
	//
	// Store image information so that it can be referenced later when
	// scheduling a job.
	AddImage(ctx context.Context, in *ImageInfo, opts ...grpc.CallOption) (*BooleanMessage, error)
	// Remove an image.
	//
	// Remove image information.
	RemoveImage(ctx context.Context, in *StringMessage, opts ...grpc.CallOption) (*BooleanMessage, error)
	// List images.
	//
	// Return the list of images and their information, matching the
	// regular expression passed as argument.
	// With an empty string the full list of images will be retrieved.
	ListImages(ctx context.Context, in *StringMessage, opts ...grpc.CallOption) (Builder_ListImagesClient, error)
}

type builderClient struct {
	cc *grpc.ClientConn
}

func NewBuilderClient(cc *grpc.ClientConn) BuilderClient {
	return &builderClient{cc}
}

func (c *builderClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error) {
	out := new(SubscribeResponse)
	err := grpc.Invoke(ctx, "/protocol.Builder/Subscribe", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	out := new(UnsubscribeResponse)
	err := grpc.Invoke(ctx, "/protocol.Builder/Unsubscribe", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) CollectJob(ctx context.Context, in *CollectJobRequest, opts ...grpc.CallOption) (*CollectJobResponse, error) {
	out := new(CollectJobResponse)
	err := grpc.Invoke(ctx, "/protocol.Builder/CollectJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) PickJob(ctx context.Context, opts ...grpc.CallOption) (Builder_PickJobClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Builder_serviceDesc.Streams[0], c.cc, "/protocol.Builder/PickJob", opts...)
	if err != nil {
		return nil, err
	}
	x := &builderPickJobClient{stream}
	return x, nil
}

type Builder_PickJobClient interface {
	Send(*PickJobRequest) error
	Recv() (*JobRequest, error)
	grpc.ClientStream
}

type builderPickJobClient struct {
	grpc.ClientStream
}

func (x *builderPickJobClient) Send(m *PickJobRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *builderPickJobClient) Recv() (*JobRequest, error) {
	m := new(JobRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *builderClient) Upload(ctx context.Context, opts ...grpc.CallOption) (Builder_UploadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Builder_serviceDesc.Streams[1], c.cc, "/protocol.Builder/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &builderUploadClient{stream}
	return x, nil
}

type Builder_UploadClient interface {
	Send(*UploadMessage) error
	CloseAndRecv() (*UploadResponse, error)
	grpc.ClientStream
}

type builderUploadClient struct {
	grpc.ClientStream
}

func (x *builderUploadClient) Send(m *UploadMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *builderUploadClient) CloseAndRecv() (*UploadResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *builderClient) Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (Builder_DownloadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Builder_serviceDesc.Streams[2], c.cc, "/protocol.Builder/Download", opts...)
	if err != nil {
		return nil, err
	}
	x := &builderDownloadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Builder_DownloadClient interface {
	Recv() (*DownloadResponse, error)
	grpc.ClientStream
}

type builderDownloadClient struct {
	grpc.ClientStream
}

func (x *builderDownloadClient) Recv() (*DownloadResponse, error) {
	m := new(DownloadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *builderClient) AddPackage(ctx context.Context, in *PackageInfo, opts ...grpc.CallOption) (*BooleanMessage, error) {
	out := new(BooleanMessage)
	err := grpc.Invoke(ctx, "/protocol.Builder/AddPackage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) RemovePackage(ctx context.Context, in *StringMessage, opts ...grpc.CallOption) (*BooleanMessage, error) {
	out := new(BooleanMessage)
	err := grpc.Invoke(ctx, "/protocol.Builder/RemovePackage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) ListPackages(ctx context.Context, in *StringMessage, opts ...grpc.CallOption) (Builder_ListPackagesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Builder_serviceDesc.Streams[3], c.cc, "/protocol.Builder/ListPackages", opts...)
	if err != nil {
		return nil, err
	}
	x := &builderListPackagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Builder_ListPackagesClient interface {
	Recv() (*PackageInfo, error)
	grpc.ClientStream
}

type builderListPackagesClient struct {
	grpc.ClientStream
}

func (x *builderListPackagesClient) Recv() (*PackageInfo, error) {
	m := new(PackageInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *builderClient) AddImage(ctx context.Context, in *ImageInfo, opts ...grpc.CallOption) (*BooleanMessage, error) {
	out := new(BooleanMessage)
	err := grpc.Invoke(ctx, "/protocol.Builder/AddImage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) RemoveImage(ctx context.Context, in *StringMessage, opts ...grpc.CallOption) (*BooleanMessage, error) {
	out := new(BooleanMessage)
	err := grpc.Invoke(ctx, "/protocol.Builder/RemoveImage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) ListImages(ctx context.Context, in *StringMessage, opts ...grpc.CallOption) (Builder_ListImagesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Builder_serviceDesc.Streams[4], c.cc, "/protocol.Builder/ListImages", opts...)
	if err != nil {
		return nil, err
	}
	x := &builderListImagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Builder_ListImagesClient interface {
	Recv() (*ImageInfo, error)
	grpc.ClientStream
}

type builderListImagesClient struct {
	grpc.ClientStream
}

func (x *builderListImagesClient) Recv() (*ImageInfo, error) {
	m := new(ImageInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Builder service

type BuilderServer interface {
	// Subscribe to the master.
	//
	// A slave calls this method to register itself on the master, which will
	// assign an identifier returned with the reply, along with some information
	// such as the repositories paths.
	//
	// Keep in mind that identifiers are valid until master is restarted.
	Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error)
	// Unregister a slave.
	//
	// Slave class this procedure to unregister itself.
	// Master replies indicating whether the operation succeded or not.
	Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error)
	// Send a job to the collector.
	//
	// Master will enqueue a new job and the dispatcher will find a suitable
	// slave and dispatch to it.
	CollectJob(context.Context, *CollectJobRequest) (*CollectJobResponse, error)
	// Pick up a job from the master.
	//
	// Once a slave has subscribed a full duplex communication is established
	// until the slave unsubscribe or the master quits, in that case the slave
	// detects that the connection is no longer valid and will resubscribe if
	// and when master comes up again.
	//
	// Master sends jobs to be processed through the stream as they are collected
	// and dispatched.  Jobs are dispatched to slaves whose capacity has not been
	// reached yet and whose topic matches.
	PickJob(Builder_PickJobServer) error
	// Upload a file to the master.
	//
	// Upload an artifact to the staging repository, a chunk at a time
	// via streaming.
	Upload(Builder_UploadServer) error
	// Download a file from the master.
	//
	// Send a file from master to slave, a chunk at a time via streaming.
	Download(*DownloadRequest, Builder_DownloadServer) error
	// Add or update a package.
	//
	// Store package information so that it can be referenced later when
	// scheduling a job.
	AddPackage(context.Context, *PackageInfo) (*BooleanMessage, error)
	// Remove a package.
	//
	// Remove package information.
	RemovePackage(context.Context, *StringMessage) (*BooleanMessage, error)
	// List packages.
	//
	// Return the list of packages and their information, matching the
	// regular expression passed as argument.
	// With an empty string the full list of packages will be retrieved.
	ListPackages(*StringMessage, Builder_ListPackagesServer) error
	// Add or update an image.
	//
	// Store image information so that it can be referenced later when
	// scheduling a job.
	AddImage(context.Context, *ImageInfo) (*BooleanMessage, error)
	// Remove an image.
	//
	// Remove image information.
	RemoveImage(context.Context, *StringMessage) (*BooleanMessage, error)
	// List images.
	//
	// Return the list of images and their information, matching the
	// regular expression passed as argument.
	// With an empty string the full list of images will be retrieved.
	ListImages(*StringMessage, Builder_ListImagesServer) error
}

func RegisterBuilderServer(s *grpc.Server, srv BuilderServer) {
	s.RegisterService(&_Builder_serviceDesc, srv)
}

func _Builder_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuilderServer).Subscribe(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builder_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuilderServer).Unsubscribe(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builder_CollectJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CollectJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuilderServer).CollectJob(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builder_PickJob_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BuilderServer).PickJob(&builderPickJobServer{stream})
}

type Builder_PickJobServer interface {
	Send(*JobRequest) error
	Recv() (*PickJobRequest, error)
	grpc.ServerStream
}

type builderPickJobServer struct {
	grpc.ServerStream
}

func (x *builderPickJobServer) Send(m *JobRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *builderPickJobServer) Recv() (*PickJobRequest, error) {
	m := new(PickJobRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Builder_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BuilderServer).Upload(&builderUploadServer{stream})
}

type Builder_UploadServer interface {
	SendAndClose(*UploadResponse) error
	Recv() (*UploadMessage, error)
	grpc.ServerStream
}

type builderUploadServer struct {
	grpc.ServerStream
}

func (x *builderUploadServer) SendAndClose(m *UploadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *builderUploadServer) Recv() (*UploadMessage, error) {
	m := new(UploadMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Builder_Download_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BuilderServer).Download(m, &builderDownloadServer{stream})
}

type Builder_DownloadServer interface {
	Send(*DownloadResponse) error
	grpc.ServerStream
}

type builderDownloadServer struct {
	grpc.ServerStream
}

func (x *builderDownloadServer) Send(m *DownloadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Builder_AddPackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PackageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuilderServer).AddPackage(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builder_RemovePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StringMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuilderServer).RemovePackage(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builder_ListPackages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StringMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BuilderServer).ListPackages(m, &builderListPackagesServer{stream})
}

type Builder_ListPackagesServer interface {
	Send(*PackageInfo) error
	grpc.ServerStream
}

type builderListPackagesServer struct {
	grpc.ServerStream
}

func (x *builderListPackagesServer) Send(m *PackageInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _Builder_AddImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ImageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuilderServer).AddImage(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builder_RemoveImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StringMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuilderServer).RemoveImage(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builder_ListImages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StringMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BuilderServer).ListImages(m, &builderListImagesServer{stream})
}

type Builder_ListImagesServer interface {
	Send(*ImageInfo) error
	grpc.ServerStream
}

type builderListImagesServer struct {
	grpc.ServerStream
}

func (x *builderListImagesServer) Send(m *ImageInfo) error {
	return x.ServerStream.SendMsg(m)
}

var _Builder_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protocol.Builder",
	HandlerType: (*BuilderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Subscribe",
			Handler:    _Builder_Subscribe_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _Builder_Unsubscribe_Handler,
		},
		{
			MethodName: "CollectJob",
			Handler:    _Builder_CollectJob_Handler,
		},
		{
			MethodName: "AddPackage",
			Handler:    _Builder_AddPackage_Handler,
		},
		{
			MethodName: "RemovePackage",
			Handler:    _Builder_RemovePackage_Handler,
		},
		{
			MethodName: "AddImage",
			Handler:    _Builder_AddImage_Handler,
		},
		{
			MethodName: "RemoveImage",
			Handler:    _Builder_RemoveImage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PickJob",
			Handler:       _Builder_PickJob_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Upload",
			Handler:       _Builder_Upload_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Download",
			Handler:       _Builder_Download_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListPackages",
			Handler:       _Builder_ListPackages_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListImages",
			Handler:       _Builder_ListImages_Handler,
			ServerStreams: true,
		},
	},
}
