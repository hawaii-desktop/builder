// Code generated by protoc-gen-go.
// source: builder.proto
// DO NOT EDIT!

/*
Package protocol is a generated protocol buffer package.

It is generated from these files:
	builder.proto

It has these top-level messages:
	SubscribeRequest
	SubscribeResponse
	UnsubscribeRequest
	UnsubscribeResponse
	JobDispatchRequest
	JobUpdateRequest
	InputMessage
	OutputMessage
	CollectJobRequest
	CollectJobResponse
*/
package protocol

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Job status.
type EnumJobStatus int32

const (
	EnumJobStatus_JOB_STATUS_JUST_CREATED EnumJobStatus = 0
	EnumJobStatus_JOB_STATUS_WAITING      EnumJobStatus = 1
	EnumJobStatus_JOB_STATUS_PROCESSING   EnumJobStatus = 2
	EnumJobStatus_JOB_STATUS_SUCCESSFUL   EnumJobStatus = 3
	EnumJobStatus_JOB_STATUS_FAILED       EnumJobStatus = 4
	EnumJobStatus_JOB_STATUS_CRASHED      EnumJobStatus = 5
)

var EnumJobStatus_name = map[int32]string{
	0: "JOB_STATUS_JUST_CREATED",
	1: "JOB_STATUS_WAITING",
	2: "JOB_STATUS_PROCESSING",
	3: "JOB_STATUS_SUCCESSFUL",
	4: "JOB_STATUS_FAILED",
	5: "JOB_STATUS_CRASHED",
}
var EnumJobStatus_value = map[string]int32{
	"JOB_STATUS_JUST_CREATED": 0,
	"JOB_STATUS_WAITING":      1,
	"JOB_STATUS_PROCESSING":   2,
	"JOB_STATUS_SUCCESSFUL":   3,
	"JOB_STATUS_FAILED":       4,
	"JOB_STATUS_CRASHED":      5,
}

func (x EnumJobStatus) String() string {
	return proto.EnumName(EnumJobStatus_name, int32(x))
}

// Subscription request.
type SubscribeRequest struct {
	// Name.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Channels.
	Channels []string `protobuf:"bytes,2,rep,name=channels" json:"channels,omitempty"`
	// Architectures.
	Architectures []string `protobuf:"bytes,3,rep,name=architectures" json:"architectures,omitempty"`
}

func (m *SubscribeRequest) Reset()         { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()    {}

// Subscription response.
type SubscribeResponse struct {
	// Slave identifier.
	Id uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *SubscribeResponse) Reset()         { *m = SubscribeResponse{} }
func (m *SubscribeResponse) String() string { return proto.CompactTextString(m) }
func (*SubscribeResponse) ProtoMessage()    {}

// Unsubscription request.
type UnsubscribeRequest struct {
	// Slave identifier.
	Id uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *UnsubscribeRequest) Reset()         { *m = UnsubscribeRequest{} }
func (m *UnsubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*UnsubscribeRequest) ProtoMessage()    {}

// Unsubscription response.
type UnsubscribeResponse struct {
	// Result.
	Result bool `protobuf:"varint,1,opt,name=result" json:"result,omitempty"`
}

func (m *UnsubscribeResponse) Reset()         { *m = UnsubscribeResponse{} }
func (m *UnsubscribeResponse) String() string { return proto.CompactTextString(m) }
func (*UnsubscribeResponse) ProtoMessage()    {}

// Contains information on the job that has to be processed by
// the slave receiving this.
type JobDispatchRequest struct {
	// Identifier.
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Target name.
	Target string `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
}

func (m *JobDispatchRequest) Reset()         { *m = JobDispatchRequest{} }
func (m *JobDispatchRequest) String() string { return proto.CompactTextString(m) }
func (*JobDispatchRequest) ProtoMessage()    {}

// Contains updated information on a job being processed.
type JobUpdateRequest struct {
	// Slave identifier.
	SlaveId uint32 `protobuf:"varint,1,opt,name=slave_id" json:"slave_id,omitempty"`
	// Identifier.
	Id uint64 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	// Current status of the job.
	Status EnumJobStatus `protobuf:"varint,3,opt,name=status,enum=protocol.EnumJobStatus" json:"status,omitempty"`
}

func (m *JobUpdateRequest) Reset()         { *m = JobUpdateRequest{} }
func (m *JobUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*JobUpdateRequest) ProtoMessage()    {}

// Communication from slave to master.
type InputMessage struct {
	// Types that are valid to be assigned to Payload:
	//	*InputMessage_Subscription
	//	*InputMessage_JobUpdate
	Payload isInputMessage_Payload `protobuf_oneof:"payload"`
}

func (m *InputMessage) Reset()         { *m = InputMessage{} }
func (m *InputMessage) String() string { return proto.CompactTextString(m) }
func (*InputMessage) ProtoMessage()    {}

type isInputMessage_Payload interface {
	isInputMessage_Payload()
}

type InputMessage_Subscription struct {
	Subscription *SubscribeRequest `protobuf:"bytes,1,opt,name=subscription,oneof"`
}
type InputMessage_JobUpdate struct {
	JobUpdate *JobUpdateRequest `protobuf:"bytes,2,opt,name=job_update,oneof"`
}

func (*InputMessage_Subscription) isInputMessage_Payload() {}
func (*InputMessage_JobUpdate) isInputMessage_Payload()    {}

func (m *InputMessage) GetPayload() isInputMessage_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *InputMessage) GetSubscription() *SubscribeRequest {
	if x, ok := m.GetPayload().(*InputMessage_Subscription); ok {
		return x.Subscription
	}
	return nil
}

func (m *InputMessage) GetJobUpdate() *JobUpdateRequest {
	if x, ok := m.GetPayload().(*InputMessage_JobUpdate); ok {
		return x.JobUpdate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InputMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _InputMessage_OneofMarshaler, _InputMessage_OneofUnmarshaler, []interface{}{
		(*InputMessage_Subscription)(nil),
		(*InputMessage_JobUpdate)(nil),
	}
}

func _InputMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InputMessage)
	// payload
	switch x := m.Payload.(type) {
	case *InputMessage_Subscription:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Subscription); err != nil {
			return err
		}
	case *InputMessage_JobUpdate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.JobUpdate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InputMessage.Payload has unexpected type %T", x)
	}
	return nil
}

func _InputMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InputMessage)
	switch tag {
	case 1: // payload.subscription
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SubscribeRequest)
		err := b.DecodeMessage(msg)
		m.Payload = &InputMessage_Subscription{msg}
		return true, err
	case 2: // payload.job_update
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JobUpdateRequest)
		err := b.DecodeMessage(msg)
		m.Payload = &InputMessage_JobUpdate{msg}
		return true, err
	default:
		return false, nil
	}
}

// Communication from master to slave.
type OutputMessage struct {
	// Types that are valid to be assigned to Payload:
	//	*OutputMessage_Subscription
	//	*OutputMessage_JobDispatch
	Payload isOutputMessage_Payload `protobuf_oneof:"payload"`
}

func (m *OutputMessage) Reset()         { *m = OutputMessage{} }
func (m *OutputMessage) String() string { return proto.CompactTextString(m) }
func (*OutputMessage) ProtoMessage()    {}

type isOutputMessage_Payload interface {
	isOutputMessage_Payload()
}

type OutputMessage_Subscription struct {
	Subscription *SubscribeResponse `protobuf:"bytes,1,opt,name=subscription,oneof"`
}
type OutputMessage_JobDispatch struct {
	JobDispatch *JobDispatchRequest `protobuf:"bytes,2,opt,name=job_dispatch,oneof"`
}

func (*OutputMessage_Subscription) isOutputMessage_Payload() {}
func (*OutputMessage_JobDispatch) isOutputMessage_Payload()  {}

func (m *OutputMessage) GetPayload() isOutputMessage_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *OutputMessage) GetSubscription() *SubscribeResponse {
	if x, ok := m.GetPayload().(*OutputMessage_Subscription); ok {
		return x.Subscription
	}
	return nil
}

func (m *OutputMessage) GetJobDispatch() *JobDispatchRequest {
	if x, ok := m.GetPayload().(*OutputMessage_JobDispatch); ok {
		return x.JobDispatch
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OutputMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _OutputMessage_OneofMarshaler, _OutputMessage_OneofUnmarshaler, []interface{}{
		(*OutputMessage_Subscription)(nil),
		(*OutputMessage_JobDispatch)(nil),
	}
}

func _OutputMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OutputMessage)
	// payload
	switch x := m.Payload.(type) {
	case *OutputMessage_Subscription:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Subscription); err != nil {
			return err
		}
	case *OutputMessage_JobDispatch:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.JobDispatch); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("OutputMessage.Payload has unexpected type %T", x)
	}
	return nil
}

func _OutputMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OutputMessage)
	switch tag {
	case 1: // payload.subscription
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SubscribeResponse)
		err := b.DecodeMessage(msg)
		m.Payload = &OutputMessage_Subscription{msg}
		return true, err
	case 2: // payload.job_dispatch
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JobDispatchRequest)
		err := b.DecodeMessage(msg)
		m.Payload = &OutputMessage_JobDispatch{msg}
		return true, err
	default:
		return false, nil
	}
}

// CollectJob request.
type CollectJobRequest struct {
	// Target name
	Target string `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
}

func (m *CollectJobRequest) Reset()         { *m = CollectJobRequest{} }
func (m *CollectJobRequest) String() string { return proto.CompactTextString(m) }
func (*CollectJobRequest) ProtoMessage()    {}

// CollectJob response.
type CollectJobResponse struct {
	// Result.
	Result bool `protobuf:"varint,1,opt,name=result" json:"result,omitempty"`
	// Identifier.
	Id uint64 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
}

func (m *CollectJobResponse) Reset()         { *m = CollectJobResponse{} }
func (m *CollectJobResponse) String() string { return proto.CompactTextString(m) }
func (*CollectJobResponse) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("protocol.EnumJobStatus", EnumJobStatus_name, EnumJobStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Builder service

type BuilderClient interface {
	// Subscribe to the master.
	//
	// A slave calls this procedure to register itself on the master, which will
	// assign an identifier and reply with a Registration message.
	// Keep in mind that identifiers are valid until master is restarted.
	//
	// Once a slave has subscribed a full duplex communication is established
	// until the slave unsubscribe or the master quits, in that case the slave
	// detects that the connection is no longer valid and will resubscribe if
	// and when master comes up again.
	//
	// Master sends jobs to be processed through the stream as they are collected
	// and dispatched.  Jobs are dispatched to slaves whose capacity has not been
	// reached yet and whose architecture and channels match.
	Subscribe(ctx context.Context, opts ...grpc.CallOption) (Builder_SubscribeClient, error)
	// Unregister a slave.
	//
	// Slave class this procedure to unregister itself.
	// Master replies indicating whether the operation succeded or not.
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error)
	// Send a job to the collector.
	//
	// Master will enqueue a new job and the dispatcher will find a suitable
	// slave and dispatch to it.
	CollectJob(ctx context.Context, in *CollectJobRequest, opts ...grpc.CallOption) (*CollectJobResponse, error)
}

type builderClient struct {
	cc *grpc.ClientConn
}

func NewBuilderClient(cc *grpc.ClientConn) BuilderClient {
	return &builderClient{cc}
}

func (c *builderClient) Subscribe(ctx context.Context, opts ...grpc.CallOption) (Builder_SubscribeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Builder_serviceDesc.Streams[0], c.cc, "/protocol.Builder/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &builderSubscribeClient{stream}
	return x, nil
}

type Builder_SubscribeClient interface {
	Send(*InputMessage) error
	Recv() (*OutputMessage, error)
	grpc.ClientStream
}

type builderSubscribeClient struct {
	grpc.ClientStream
}

func (x *builderSubscribeClient) Send(m *InputMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *builderSubscribeClient) Recv() (*OutputMessage, error) {
	m := new(OutputMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *builderClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	out := new(UnsubscribeResponse)
	err := grpc.Invoke(ctx, "/protocol.Builder/Unsubscribe", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *builderClient) CollectJob(ctx context.Context, in *CollectJobRequest, opts ...grpc.CallOption) (*CollectJobResponse, error) {
	out := new(CollectJobResponse)
	err := grpc.Invoke(ctx, "/protocol.Builder/CollectJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Builder service

type BuilderServer interface {
	// Subscribe to the master.
	//
	// A slave calls this procedure to register itself on the master, which will
	// assign an identifier and reply with a Registration message.
	// Keep in mind that identifiers are valid until master is restarted.
	//
	// Once a slave has subscribed a full duplex communication is established
	// until the slave unsubscribe or the master quits, in that case the slave
	// detects that the connection is no longer valid and will resubscribe if
	// and when master comes up again.
	//
	// Master sends jobs to be processed through the stream as they are collected
	// and dispatched.  Jobs are dispatched to slaves whose capacity has not been
	// reached yet and whose architecture and channels match.
	Subscribe(Builder_SubscribeServer) error
	// Unregister a slave.
	//
	// Slave class this procedure to unregister itself.
	// Master replies indicating whether the operation succeded or not.
	Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error)
	// Send a job to the collector.
	//
	// Master will enqueue a new job and the dispatcher will find a suitable
	// slave and dispatch to it.
	CollectJob(context.Context, *CollectJobRequest) (*CollectJobResponse, error)
}

func RegisterBuilderServer(s *grpc.Server, srv BuilderServer) {
	s.RegisterService(&_Builder_serviceDesc, srv)
}

func _Builder_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BuilderServer).Subscribe(&builderSubscribeServer{stream})
}

type Builder_SubscribeServer interface {
	Send(*OutputMessage) error
	Recv() (*InputMessage, error)
	grpc.ServerStream
}

type builderSubscribeServer struct {
	grpc.ServerStream
}

func (x *builderSubscribeServer) Send(m *OutputMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *builderSubscribeServer) Recv() (*InputMessage, error) {
	m := new(InputMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Builder_Unsubscribe_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BuilderServer).Unsubscribe(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builder_CollectJob_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(CollectJobRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BuilderServer).CollectJob(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Builder_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protocol.Builder",
	HandlerType: (*BuilderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Unsubscribe",
			Handler:    _Builder_Unsubscribe_Handler,
		},
		{
			MethodName: "CollectJob",
			Handler:    _Builder_CollectJob_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _Builder_Subscribe_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}
